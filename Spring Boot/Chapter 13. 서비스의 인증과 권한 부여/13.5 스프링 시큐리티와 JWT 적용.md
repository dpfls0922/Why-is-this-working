## 13.5 스프링 시큐리티와 JWT 적용

우선 인증과 인가 코드를 작성하기 위해 의존성을 추가한다.

```
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-security</artifactId>
</dependency>
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt</artifactId>
  <version>0.9.1</version>
</dependency>
```

스프링 시큐리티는 기본적으로 `UsernamePasswordAuthenticationFilter`를 통해 인증을 수행하도록 구성돼있다.

- 이 필터는 인증이 실패하면 로그인 폼이 포함된 화면을 전달하게 되는데, 이 프로젝트에는 이러한 화면 존재하지 않음
- 따라서 JWT를 사용하는 인증 필터를 구현하고 `UsernamePasswordAuthenticationFilter`` 앞에 인증 필터를 배치해서 인증 주체를 변경하는 작업을 수행하는 방식으로 구성

### 13.5.1 UserDetails와 UserDetailsServcie 구현

**User(사용자 정보) 엔티티 생성**

```java
@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Table
public class User implements UserDetails {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    @Column(nullable = false, unique = true)
    private String uid;

    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
    @Column(nullable = false)
    private String password;

    @Column(nullable = false)
    private String name;

    @ElementCollection(fetch = FetchType.EAGER)
    @Builder.Default
    private List<String> roles = new ArrayList<>();

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return this.roles.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toList());
    }

    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
    @Override
    public String getUsername() {
        return this.uid;
    }

    @JsonProperty(access =  JsonProperty.Access.WRITE_ONLY)
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
    @Override
    public boolean isEnabled() {
        return false;
    }
}

```

이 엔티티는 UserDetailService를 통해 입력된 로그인 정보를 가지고 데이터베이스에서 사용자 정보를 가져오는 역할을 수행한다.

**UserDetails 인터페이스**

```java
public interface UserDetails extends Serializable {
    Collection<? extends GrantedAuthority> getAuthorities();

    String getPassword();

    String getUsername();

    boolean isAccountNonExpired();

    boolean isAccountNonLocked();

    boolean isCredentialsNonExpired();

    boolean isEnabled();
}
```

- `getAuthorities()` : 계정이 가지고 있는 권한 목록 리턴
- `getPassword()` : 계정의 비밀번호 리턴
- `getUsername()` : 계정 이름 리턴
- `isAccountNonExpired()` : 계정이 만료됐는지 리턴 → true는 완료되지 않음 의미
- `isAccountNonLocked()` : 계정이 잠겨있는지 리턴 → true는 잠기지 않음
- `isCredentialNonExpired()` : 비밀번호가 만료됐는지 리턴 → true는 만료X 의미
- `isEnabled()` : 계정이 활성화돼 있는지 리턴 → true는 활성화 상태 의미

**엔티티를 조회하기 위한 리포지토리와 서비스 구현**

```java
public interface UserRepository  extends JpaRepository<User, Long> {

    User getByUid(String uid);
}
```

ID 값은 인덱스 값이기 때문에 id값을 토큰 생성 정보로 사용하기 위해 `getByUid()` 메서드를 생성한다.

리포지토리를 통해 User 엔티티의 id를 가져오는 서비스를 생성한다.

**UserDetailsServiceImpl 구현**

```java
@RequiredArgsConstructor
@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    private final Logger LOGGER = LoggerFactory.getLogger(UserDetailsServiceImpl.class)

    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username){
        LOGGER.info("[loadUserByUsername] loadUserByUsername 수행. username : {}", username);
        return userRepository.getByUid(username);
    }
}
```

```java
package org.springframework.security.core.userdetails;

public interface UserDetailsService {
    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
}
```

`UserDetails`는 스프링 시큐리티에서 제공하는 개념으로, UserDetails의 username은 각 사용자를 구분할 수 있는 ID를 의미한다. 위 인터페이스를 보면 username을 가지고 UserDetails 객체를 리턴하는데, UserDetails의 구현체로 User 엔티티를 생성하였기에 User 객체를 리턴하게끔 구현한 것이다.

### 13.5.2 JwtTokenProvider 구현

이제 JWT 토큰을 생성하는데 필요한 정보를 UserDetails에서 가져올 수 있기 때문에 JWT 토큰을 생성하는 `JwtTokenProvider`를 생성한다.

**JwtTokenProvider 구현**

```java
@Component
@RequiredArgsConstructor
public class JwtTokenProvider {

    private final Logger LOGGER = LoggerFactory.getLogger(JwtTokenProvider.class);
    private final UserDetailsService userDetailsService;

    @Value("${springboot.jwt.secret}")
    private String secretKey = "secretKey";
    private final long tokenValidMillisecond = 1000L * 60* 60;

    @PostConstruct
    protected void init(){
        LOGGER.info("[init] JwtTokenProvider 내 secretKey 초기화 시작");
        secretKey = Base64.getEncoder().encodeToString(secretKey.getBytes(StandardCharsets.UTF_8));

        LOGGER.info("[init] JwtTokenProvider 내 SecretKey 초기화 완료");
    }

    public String createToken(String userUid, List<String> roles){
        LOGGER.info("[createToken] 토큰 생성 시작");
        Claims claims = Jwts.claims().setSubject(userUid);
        claims.put("roles", roles);
        Date now = new Date();

        String token = Jwts.builder()
                .setClaims(claims)
                .setIssuedAt(now)
                .setExpiration(new Date(now.getTime() + tokenValidMillisecond))
                .signWith(SignatureAlgorithm.HS256, secretKey)
                .compact();

        LOGGER.info("[createToken] 토큰 생성 완료");
        return token;
    }

    public Authentication getAuthentication(String token){
        LOGGER.info("[getAuthentication] 토큰 인증 정보 조회 시작");
        UserDetails userDetails = userDetailsService.loadUserByUsername(this.getUsername(token));
        LOGGER.info("[getAuthentication] 토큰 인증 정보 조회 완료, UserDetails UserName : {}",
                userDetails.getUsername());
        return new UsernamePasswordAuthenticationToken(userDetails,"", userDetails.getAuthorities());
    }

    public String getUsername(String token){
        LOGGER.info("[getUsername] 토큰 기반 회원 구별 정보 추출");
        String info = Jwts.parser().setSigningKey(secretKey).parseClaimsJwt(token).getBody()
                .getSubject();
        LOGGER.info("[getUsername] 토큰 기반 회원 구별 정보 추출 완료, info: {}", info);
        return info;
    }

    public String resolveToken(HttpServletRequest request){
        LOGGER.info("[resolveToken] HTTP 헤더에서 Token 값 추출");
        return request.getHeader("X-AUTH-TOKEN");
    }

    public boolean validateToken(String token){
        LOGGER.info("[validateToken] 토큰 유효 체크 시작 ");
        try{
            Jws<Claims> claims = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token);
            return !claims.getBody().getExpiration().before(new Date());
        } catch(Exception e){
            LOGGER.info("[validateToken] 토큰 유효 체크 예외 발생");
            return false;
        }
    }
}

```

우선 토큰 생성을 하기 위해 secretKey가 필요하므로 secretKey 값을 정의한다.

@Value 값은 properties 파일에서 정의할 수 있다.

```
spring.jwt.secret = flature!@#
```

**init() 메서드**

```java
 	@PostConstruct
    protected void init(){
        LOGGER.info("[init] JwtTokenProvider 내 secretKey 초기화 시작");
        System.out.println(secretKey)
        secretKey = Base64.getEncoder().encodeToString(secretKey.getBytes(StandardCharsets.UTF_8));
        System.out.println(secretKey)

        LOGGER.info("[init] JwtTokenProvider 내 SecretKey 초기화 완료");
    }
```

`@PostConstruct`는 해당 객체가 빈 객체로 주입된 이후 수행되는 메서드를 가리킨다.

앞서 JwtTokenProvider 클래스 작성 전 @Component를 지정하여 애플리케이션을 실행하면 `빈으로 자동 주입된다.` 그때 @PostConstruct 지정돼 있는 init() 메서드가 자동으로 실행된다. init 메서드에서는 secretkey를 base64 형식으로 인코딩한다.

```
인코딩 전 원본 문자열
flature!@#

Base64 인코딩 결과
ZmxhdHVyZSFAIw==
```

**createToken() 메서드**

```java
public String createToken(String userUid, List<String> roles){
        LOGGER.info("[createToken] 토큰 생성 시작");
        Claims claims = Jwts.claims().setSubject(userUid);
        claims.put("roles", roles);
        Date now = new Date();

        String token = Jwts.builder()
                .setClaims(claims)
                .setIssuedAt(now)
                .setExpiration(new Date(now.getTime() + tokenValidMillisecond))
                .signWith(SignatureAlgorithm.HS256, secretKey)
                .compact();

        LOGGER.info("[createToken] 토큰 생성 완료");
        return token;
    }

```

JWT 토큰에 값을 넣기 위해 Claims 객체를 생성한다. `setSubject()` 메서드를 통해 sub 속성에 값을 추가하려면 User의 uid 값을 사용한다.

그 다음에는 해당 토큰을 사용하는 사용자의 권한을 확인할 수 있는 `role` 값을 별개로 추가한다.

`Jwts.builder()`를 사용해 토큰 생성한다.

**getAuthentication() 메서드**

```java
public Authentication getAuthentication(String token){
        LOGGER.info("[getAuthentication] 토큰 인증 정보 조회 시작");
        UserDetails userDetails = userDetailsService.loadUserByUsername(this.getUsername(token));
        LOGGER.info("[getAuthentication] 토큰 인증 정보 조회 완료, UserDetails UserName : {}",
                userDetails.getUsername());
        return new UsernamePasswordAuthenticationToken(userDetails,"", userDetails.getAuthorities());
    }
```

이 메서드는 필터에서 인증이 성공했을 때 `SecurityContextHolder에 저장할 Authentication 생성하는 역할`을 한다. Authentication을 구현하는 편한 방법은 `UsernamePasswordAuthenticationToken`를 사용하는 것이다.

UsernamePasswordAuthenticationToken은 AbstractAuthenticationToken을 상속 받고 있는데 이는 `Authentication< interface >` 와 `CredentialsContainer < interface >` 의 구현체이다.

이러한 토큰 클래스를 사용하려면 초기화를 위한 UserDetails가 필요하다.

- 여기선 UserDetailsService를 통해 가져옴

이때 사용한 Username은 밑과 같이 구현한다.

**getUsername() 메서드**

```java
 public String getUsername(String token){
        LOGGER.info("[getUsername] 토큰 기반 회원 구별 정보 추출");
        String info = Jwts.parser().setSigningKey(secretKey).parseClaimsJwt(token).getBody()
                .getSubject();
        LOGGER.info("[getUsername] 토큰 기반 회원 구별 정보 추출 완료, info: {}", info);
        return info;
    }

```

Jwts.parser() 를 통해 secretkey를 설정하고 클레임을 추출하여 토큰을 생성할 때 넣었던 sub 값을 추출한다.

**resolveToken() 메서드**

```java
public String resolveToken(HttpServletRequest request){
        LOGGER.info("[resolveToken] HTTP 헤더에서 Token 값 추출");
        return request.getHeader("X-AUTH-TOKEN");
    }
```

이는 HttpServletRequest를 파라미터로 받아 헤더 값으로 전달된 X-AUTH-TOKEN 값을 가져와 리턴한다. 클라이언트가 헤더를 통해 애플리케이션 서버로 JWT 토큰 값을 전달해야 정상적인 추출이 가능하다. 헤더의 이름은 임의로 변경할 수 있다.

**validateToken() 메서드**

```java
 public boolean validateToken(String token){
        LOGGER.info("[validateToken] 토큰 유효 체크 시작 ");
        try{
            Jws<Claims> claims = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token);
            return !claims.getBody().getExpiration().before(new Date());
        } catch(Exception e){
            LOGGER.info("[validateToken] 토큰 유효 체크 예외 발생");
            return false;
        }
    }
```

이 메서드는 토큰을 전달받아 클레임의 유효기간을 체크하고 boolean 타입의 값을 리턴하는 역할을 한다.

### 13.5.3 JwtAuthenticationFilter 구현

`JwtAuthenticationFilter`는 JWT 토큰으로 인증하고 `SecurityContextHolder`에 추가하는 필터를 설정하는 클래스이다.

**JwtAuthenticationFilter 클래스**

```java
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final Logger LOGGER = LoggerFactory.getLogger(JwtAuthenticationFilter.class);
    private final JwtTokenProvider jwtTokenProvider;

    public JwtAuthenticationFilter(JwtTokenProvider jwtTokenProvider){
        this.jwtTokenProvider = jwtTokenProvider;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest servletRequest, HttpServletResponse servletResponse, FilterChain filterChain) throws ServletException, IOException {
        String token = jwtTokenProvider.resolveToken(servletRequest);
        LOGGER.info("[doFilterInternal] token 값 추출 완료, token: {}", token);

        LOGGER.info("[doFilterInternal] token 값 유효성 체크 시작");
        if(token != null && jwtTokenProvider.validateToken(token)){
            Authentication authentication = jwtTokenProvider.getAuthentication(token);
            SecurityContextHolder.getContext().setAuthentication(authentication);
            LOGGER.info("[doFilterInternal] token 값 유효성 체크 완료");
        }

        filterChain.doFilter(servletRequest, servletResponse);
    }
}
```

스프링 부트에서는 필터를 여러 방법으로 구현하는데, 가장 편한 구현 방법은 필터를 상속받아 사용하는 것이다.

- 대표적인 상속 객체는 `GenericFilterBean` & `OncePerRequestFilter`

**GenericFilterBean을 상속받아 구현한 경우**

```java
public class JwtAuthenticationFilter extends GenericFilterBean{

    private final Logger LOGGER = LoggerFactory.getLogger(JwtAuthenticationFilter.class);
    private final JwtTokenProvider jwtTokenProvider;

    public JwtAuthenticationFilter(JwtTokenProvider jwtTokenProvider){
        this.jwtTokenProvider = jwtTokenProvider;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest servletRequest, HttpServletResponse servletResponse, FilterChain filterChain) throws ServletException, IOException {
        String token = jwtTokenProvider.resolveToken((HttpServletRequest) servletRequest);
        LOGGER.info("[doFilterInternal] token 값 추출 완료, token: {}", token);

        LOGGER.info("[doFilterInternal] token 값 유효성 체크 시작");
        if(token != null && jwtTokenProvider.validateToken(token)){
            Authentication authentication = jwtTokenProvider.getAuthentication(token);
            SecurityContextHolder.getContext().setAuthentication(authentication);
            LOGGER.info("[doFilterInternal] token 값 유효성 체크 완료");
        }

        filterChain.doFilter(servletRequest, servletResponse);
    }
}
```

> `GenericFilterBean`은 기존 필터에서 가져올 수 없는 스프링의 설정 정보를 가져올 수 있게 확장된 추상 클래스이다.
다만 서블릿은 사용자의 요청을 받으면 서블릿을 생성해서 메모리에 저장해두고 동일한 클라이언트의 요청을 받으면 재활용하는 구조여서 이를 상속받으면 RequestDispatcher에 의해 다른 서블릿으로 디스패치 되면서 필터가 두 번 실행될 수 있다.
이같은 문제를 해결하기 위해 등장한 것이 `OncePerRequestFilter`이며 이 또한 `GenericFilterBean`을 상속받고 있다. 다만 이 클래스를 상속받아 구현한 필터는 매 요청마다 한 번만 실행되게끔 구현된다.
> 

`doFilter()`는 서블릿을 실행하는 메서드인데, 이를 기존으로 앞에 작성한 코드는 서블릿 실행되기 전에 실행되고, 뒤에 작성한 코드는 서블릿 실행된 후 실행된다.

메서드 로직을 보면 `JwtTokenProvider`를 통해 `servletRequest`에서 토큰을 추출하고, 토큰에 대한 유효성을 검사한다. 토큰이 유효하다면 `Authentication` 객체를 생성해서 `SecurityContextHolder`에 추가하는 작업을 수행한다.

### 13.5.4 Security Configuration 구현

지금까지 `스프링 시큐리티를 적용하기 위한 컴포넌트를 구현하였다.`

스프링 시큐리티 관련 설정을 진행하는 대표적인 방법은 `WebSecurityConfigureAdapter`를 상속받는 `Configuration` 클래스를 구현하는 것이다.

**SecurityConfiguration 클래스**

```java
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

    private final JwtTokenProvider jwtTokenProvider;

    @Autowired
    public SecurityConfiguration(JwtTokenProvider jwtTokenProvider){
        this.jwtTokenProvider = jwtTokenProvider;
    }

    @Override
    protected void configure(HttpSecurity httpSecurity) throws Exception{
        httpSecurity.httpBasic().disable()

                .csrf().disable()

                .sessionManagement()
                .sessionCreationPolicy(
                        SessionCreationPolicy.STATELESS)
                .and()
                .authorizeRequests()
                .antMatchers("/sign-api/sign-in", "/sign-api/sign-up",
                        "/sign-api/exception").permitAll()
                .antMatchers(HttpMethod.GET, "/product/**").permitAll()
                .antMatchers("**exception**").permitAll()

                .anyRequest().hasRole("ADMIN")

                .and()
                .exceptionHandling().accessDeniedHandler(new CustomAccessDeniedHandler())
                .and()
                .exceptionHandling().authenticationEntryPoint(new CustomAuthenticationEntryPoint())

                .and()
                .addFilterBefore(new JwtAuthenticationFilter(jwtTokenProvider),
                        UsernamePasswordAuthenticationFilter.class);
    }

    @Override
    public void configure(WebSecurity webSecurity){
        webSecurity.ignoring().antMatchers("/v2/api-docs", "/swagger-resources/**",
                "/swagger-ui.html", "/webjars/**", "/swagger/**", "/sign-api/exception");
    }

}
```

SecurityConfiguration 클래스의 주요 메서드는 두 가지로, `WebSecurity 파라미터를 받은 configure() 메서드`와 `HttpSecurity 파라미터를 configure() 메서드`이다.

대부분의 시큐리티 설정은 WebSecurity를 통해 진행된다. 대표적인 기능은 아래와 같다.

- 리소스 접근 권한 설정
- 인증 실패 시 발생하는 예외처리
- 인증 로직 커스터마이징
- csrf,cors 등의 스프링 시큐리티 설정

**HttpSecurity를 사용하는 configure() 메서드**

모든 설정은 전달받은 HttpSecurity에 설정하게 된다.

- `httpBasic().disable()`
    - UI를 사용하는 것을 기본값으로 가진 시큐리티 설정을 비활성화
- `csrf().disable()`
    - REST API에서는 CSRF(사이트 간 요청 위조) 보안이 필요 없기 때문에 비활성화 하는 로직, csrf() 메서드는 기본적으로 CSRF 토큰을 발급해서 클라이언트로부터 요청을 받을 때 마다 토큰을 검증하는 방식으로 동작, 브라우저 사용환경이 아니라면 비활성화 해도 크게 문제 X
- `sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)`
    - RESTAPI 기반 애플리케이션의 동작 방식 설정, 현재는 JWT 토큰으로 인증을 처리하며, 세션을 사용하지 않기에 STATELESS로 진행
- `authorizeRequest()`
    - 애플리케이션에 들어오는 요청에 대한 사용 권한 체크, 이후 `antMatchers() 메서드`는 antPattern을 통해 권한 설정
    - "/sign-api/sign-in", "/sign-api/sign-up","/sign-api/exception" 경로에 대해서는 모에게 허용
    - /product로 시작하는 경로의 GET요청은 모두 허용
    - exception 단어가 들어간 경로는 모든 허용
    - 기타 요청은 인증된 권한을 가진 사용자에게 허용
- `exceptionHandling().accessDeniedHandler()`
    - 권한을 확인하는 과정에서 통과하지 못하는 예외가 있을 경우 예외 전달
- `exceptionHandling().authenticationEntryPoint()`
    - 인증 과정에서 예외가 발생하는 경우 예외 전달

각 메서드는 `CustomAccessDeniedHandler`와 `CustomAuthenticationEntryPoint`로 예외를 전달한다.

스프링 시큐리티는 각각의 역할을 수행하는 필터들이 체인 형태로 구성돼 순서대로 동작한다. 여기선 JWT로 인증하는 필터를 생성하였고, 필터의 등록은 HttpSecurity 설정에서 진행한다.

`addFilterBefore()` 메서드를 통해 어느 필터 앞에 추가할지 설정할 수 있다.

- 위 코드에서는 스프링 시큐리티에서 인증을 처리하는 필터인 `UsernamePasswordAuthenticationFilter` 앞에 앞에서 생성한 `JwtAuthenticationFilter`를 추가하겠다는 의미

**WebSecurity를 사용하는 configure() 메서드**

- WebSecurity는 HttpSecurity 앞단에 적용되며, 전체적으로 스프링 시큐리티 영향 밖
- 즉 인증과 인가가 모두 적용되기 전에 동작하는 설정
- 인증과 인가가 적용되지 않는 리소스 접근에 대해서만 사용

위 코드에서는 Swagger 관련된 경로에 대한 예외 처리를 수행한다.

- `즉 인증과 인가를 무시하는 경로를 설정하는 것`

### 13.5.5 커스텀 AccessDeniedHandler, AuthenticationEntryPoint 구현

앞선 페이지에서 인증과 인가 과정의 예외 상황에서 `AccessDeniedHandler`, `AuthenticationEntryPoint`로 예외를 전달한다. 이러한 클래스를 작성하는 방법을 알아본다.

**AccessDeniedHandler 인터페이스 구현체 클래스 생성**

```java
@Component
public class CustomAccessDeniedHandler implements AccessDeniedHandler {

    private final Logger LOGGER = LoggerFactory.getLogger(CustomAccessDeniedHandler.class);

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {
        LOGGER.info("[handle] 접근이 막혔을 경우 경로 리다이렉트");
        response.sendRedirect("/sign-api/exception");
    }
}
```

`AccessDeniedException`은 엑세스 권한이 없는 리소스에 접근 시 발생하는 예외이다.

- 이를 처리하기 위해 AccessDeniedHandler 인터페이스가 사용되며, SecurityConfiguration에도 exceptionHandling() 메서드를 통해 추가함

`handle()` 메서드를 오버라이딩 한다. 이 메서드는 HttpServletRequest와 HttpServletResponse, AccessDeniedException을 파라미터로 가져온다.

response에서 리다이렉트하는 `sendRedirect()`메서드를 활용하는 방식으로 구현한다.

- 접근이 막혔을 경우 경로 리다이렉트가 출력된 후 다른 스레드에서 동작하게 됨

인증이 실패한 상황을 처리하는 AuthenticationEntryPoint 인터페이스를 구현한 경우를 살펴본다.

**CustomAuthenticationEntryPoint 클래스**

```java
@Component
public class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint {

    private final Logger LOGGER = LoggerFactory.getLogger(CustomAuthenticationEntryPoint.class)

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
        ObjectMapper objectMapper = new ObjectMapper();
        LOGGER.info("[commence] 인증 실패로 response.sendError 발생");

        EntryPointErrorResponse entryPointErrorResponse = new EntryPointErrorResponse();
        entryPointErrorResponse.setMsg("인증이 실패하였습니다");

        response.setStatus(401);
        response.setContentType("application/json");
        response.setCharacterEncoding("utf-8");
        response.getWriter().write(objectMapper.writeValueAsString(entryPointErrorResponse));
    }
}

```

**EntryPointErrorResponse 클래스**

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
@ToString
public class EntryPointErrorResponse {

    private String msg;
}
```

구조가 앞선 `AccessDeniedHandler`와 크게 다르지 않으며, `commence()` 오버라이딩한다.

예외 처리를 위해 리다이렉트가 아니라 직접 Response를 생성해서 클라이언트에게 응답하는 방식으로 구현돼 있다.

컨트롤러에서는 응답을 위한 설정들이 자동으로 구현되기에 별도의 작업을 하지 않았지만 여기서는 응답값을 설정해 주어야 한다.

- 메세지 담기 위해 EntryPointErrorResponse 객체 사용해 메세지를 설정하고, response에 `상태 코드(status)`와 `콘텐츠 타입(Content-type)` 등을 설정한 후 ObjectMapper를 사용해 EntryPointErrorResponse 객체를 바디 값으로 파싱함

**HttpServletResponse의 응답 코드 설정**

```java
@Override
public void commence(HttpServletRequest request, HttpServletResponse response
, AuthenticationException ex) throws IOExcpetion{
	reponse.sendError(HttpServletResponse.SC_UNAUTHORIZED);
}
```

### 13.5.6 회원가입과 로그인 구현

그 전에 UserDetails 인터페이스의 구현체 클래스로 User 엔티티를 생성했다.

지금까지는 User 객체를 통해 인증하는 방법을 구현했는데, 여기선 회원가입을 구현하고 User 객체로 인증을 시도하는 로그인을 구현할 것이다.

회원가입과 로그인의 도메인은 Sign으로 통합해서 표현할 예정이며, 각각 `Sign-up`, `Sign-in`으로 구분해서 기능을 구현한다.

**서비스 레이어 구현**

```java
public interface SignService {

    SignUpResultDto signUp(String id, String password, String name, String role);

    SignInResultDto signIn(String id, String password) throws  RuntimeException;
}
```

**SignService 인터페이스 구현**

```java
@Service
public class SignServiceImpl implements SignService {

    private final Logger LOGGER = LoggerFactory.getLogger(SignServiceImpl.class);

    public UserRepository userRepository;
    public JwtTokenProvider jwtTokenProvider;
    public PasswordEncoder passwordEncoder;

    @Autowired
    public SignServiceImpl(UserRepository userRepository, JwtTokenProvider jwtTokenProvider,
                           PasswordEncoder passwordEncoder){
        this.userRepository = userRepository;
        this.jwtTokenProvider = jwtTokenProvider;
        this.passwordEncoder = passwordEncoder;
    }

    @Override
    public SignUpResultDto signUp(String id, String password, String name, String role) {
        LOGGER.info("[getSignUpResult] 회원 가입 정보 전달");
        User user;
        if(role.equalsIgnoreCase("admin")){
            user = User.builder()
                    .uid(id)
                    .name(name)
                    .password(passwordEncoder.encode(password))
                    .roles(Collections.singletonList(password))
                    .build();
        } else{
            user = User.builder()
                    .uid(id)
                    .name(name)
                    .password(passwordEncoder.encode(password))
                    .roles(Collections.singletonList("ROLE_USER"))
                    .build();
        }

        User savedUser = userRepository.save(user);
        SignUpResultDto signUpResultDto = new SignInResultDto();

        LOGGER.info("[getSignUpResult] userEntity 값이 들어왔는지 확인 후 결과 주입");
        if(!savedUser.getName().isEmpty()){
            LOGGER.info("[getSignUpResult] 정상 처리 완료");
            setSuccessResult(signUpResultDto);
        } else{
            LOGGER.info("[getSignUpResult] 실패 처리 완료");
            setFailResult(signUpResultDto);
        }
        return signUpResultDto;
    }

    @Override
    public SignInResultDto signIn(String id, String password) throws RuntimeException {
        LOGGER.info("[getSignInResult] signDataHandler로 회원 정보 요청");
        User user = userRepository.getByUid(id);
        LOGGER.info("[getSignInResult] Id : {}", id);

        LOGGER.info("[getSignInResult] 패스워드 비교 수행");
        if(!passwordEncoder.matches(password, user.getPassword())){
            throw new RuntimeException();
        }

        LOGGER.info("[getSignInResult] 패스워드 일치");

        LOGGER.info("[getSignInResult] SignInResultDto 객체 생성");
        SignInResultDto signInResultDto = SignInResultDto.builder()
                .token(jwtTokenProvider.createToken(String.valueOf(user.getUid()),
                        user.getRoles()))
                .build();

        LOGGER.info("[getSignInResult] SignInResultDto 객체에 값 주입");
        setSuccessResult(signInResultDto);

        return signInResultDto;
    }

    private void setSuccessResult(SignUpResultDto result){
        result.setSuccess(true);
        result.setCode(CommonResponse.SUCCESS.getCode());
        result.setMsg(CommonResponse.SUCCESS.getMsg());
    }

    private void setFailResult(SignUpResultDto result){
        result.setSuccess(false);
        result.setCode(CommonResponse.FAIL.getCode());
        result.setMsg(CommonResponse.FAIL.getMsg());
    }
}
```

우선 초반에 회원가입과 로그인을 구현하기 위해 세 가지 객체에 대한 의존성 주입을 받는다.

**signUp(회원가입 구현)**

- ADMIN및 USER 권한으로 구분된 role 객체를 확인해 User 엔티티의 roles 변수에 추가해서 엔티티 생성함
- 패스워드는 암호화해서 저장해야 하기 때문에 `PasswordEncoder`를 활용해 인코딩을 수행함
- PassWordEncoder는 별도의 @Configuration 클래스를 생성하고 @Bean 객체로 등록하도록 구현함

**PasswrodEncoderConfiguration 클래스**

```java
@Configuration
public class PasswordEncoderConfiguration {

    @Bean
    public PasswordEncoder passwordEncoder(){
        return PasswordEncoderFactories.createDelegatingPasswordEncoder();
    }
}
```

위 코드는 빈 객체를 등록하기 위해서 생성된 클래스이기에, SecurityConfiguration 클래스 같은 이미 생성된 @Configuration 클래스 내부에 passwordEncoder() 메서드를 정의해도 충분하다.

이렇게 생성된 엔티티를 UserRepository를 통해 저장한다.

이후 `SignIn 메서드`에서 로그인 메서드 구현

- 로그인 : 미리 저장돼 있는 계정 정보와 요청을 통해 전달된 계정 정보가 일치하는지 확인하는 작업

**SignIn(로그인 내부 로직)**

- `id를 기반`으로 UserRepository에서 User엔티티를 가져옴
- `PassWordEncoder`를 사용해 DB에 저장돼 있던 패스워드와 입력받은 패스워드가 일치하는지 확인하는 작업 수행, 위에선 RuntimeException을 사용했지만 별도의 커스텀 예외 만들기도 함
- 패스워드가 일치해서 인증을 통과하면 `JwtTokenProvider`를 통해 `id와 role 값을 전달`해서 토큰을 생성한 후 `Response에 담아 전달`함

**코드 마지막 부분에 사용된 CommonResponse 열거체**

```java
package com.springboot.security.common;

public enum CommonResponse {

    SUCCESS(0, "Success"), FAIL(-1, "Fail");

    int code;
    String msg;

    CommonResponse(int code, String msg){
        this.code = code;
        this.msg = msg;
    }

    public int getCode(){
        return code;
    }

    public String getMsg(){
        return msg;
    }
}
```

이후 회원가입과 로그인을 API로 노출하는 컨트롤러 생성해야 한다.

- 사실상 서비스 레이어로 요청을 전달하고 응답하는 역할만 수행

**SignController 클래스**

```java
@RestController
@RequestMapping("/sign-api")
public class SignController {

    private final Logger LOGGER = LoggerFactory.getLogger(SignController.class);
    private final SignService signService;

    @Autowired
    public SignController(SignService signService) {
        this.signService = signService;
    }

    @PostMapping(value = "/sign-in")
    public SignInResultDto signIn(
        @ApiParam(value = "ID", required = true) @RequestParam String id,
        @ApiParam(value = "Password", required = true) @RequestParam String password)
        throws RuntimeException {
        LOGGER.info("[signIn] 로그인을 시도하고 있습니다. id : {}, pw : ****", id);
        SignInResultDto signInResultDto = signService.signIn(id, password);

        if (signInResultDto.getCode() == 0) {
            LOGGER.info("[signIn] 정상적으로 로그인되었습니다. id : {}, token : {}", id,
                signInResultDto.getToken());
        }
        return signInResultDto;
    }

    @PostMapping(value = "/sign-up")
    public SignUpResultDto signUp(
        @ApiParam(value = "ID", required = true) @RequestParam String id,
        @ApiParam(value = "비밀번호", required = true) @RequestParam String password,
        @ApiParam(value = "이름", required = true) @RequestParam String name,
        @ApiParam(value = "권한", required = true) @RequestParam String role) {
        LOGGER.info("[signUp] 회원가입을 수행합니다. id : {}, password : ****, name : {}, role : {}", id,
            name, role);
        SignUpResultDto signUpResultDto = signService.signUp(id, password, name, role);

        LOGGER.info("[signUp] 회원가입을 완료했습니다. id : {}", id);
        return signUpResultDto;
    }

    @GetMapping(value = "/exception")
    public void exceptionTest() throws RuntimeException {
        throw new RuntimeException("접근이 금지되었습니다.");
    }

    @ExceptionHandler(value = RuntimeException.class)
    public ResponseEntity<Map<String, String>> ExceptionHandler(RuntimeException e) {
        HttpHeaders responseHeaders = new HttpHeaders();
        //responseHeaders.add(HttpHeaders.CONTENT_TYPE, "application/json");
        HttpStatus httpStatus = HttpStatus.BAD_REQUEST;

        LOGGER.error("ExceptionHandler 호출, {}, {}", e.getCause(), e.getMessage());

        Map<String, String> map = new HashMap<>();
        map.put("error type", httpStatus.getReasonPhrase());
        map.put("code", "400");
        map.put("message", "에러 발생");

        return new ResponseEntity<>(map, responseHeaders, httpStatus);
    }

}
```

클라이언트는 위와 같이 계정을 생성하고 로그인 과정을 거쳐 토큰값을 전달받음으로써 이 애플리케이션이 제공하는 API 서비스를 사용할 준비를 마친다.

**Response로 전달되는 SignUpResultDto와 SignInResultDto 클래스**

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
@ToString
public class SignInResultDto extends SignUpResultDto {

    private String token;

    @Builder
    public SignInResultDto(boolean success, int code, String msg, String token) {
        super(success, code, msg);
        this.token = token;
    }

}
```

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
@ToString
public class SignUpResultDto {

    private boolean success;

    private int code;

    private String msg;

}
```

여기까지 구현하면 정상적으로 스프링 시큐리티가 동작하는 애플리케이션 환경이 완성된 것이다.

### 13.5.7 스프링 시큐리티 테스트

클라이언트의 입장에서 스프링 시큐리티가 동작하는 상황에 대해 테스트 수행(Swagger 활용)해본다. Swagger 페이지를 접속하는 경로는 WebSecurity를 사용하는 configure() 메서드에서 인증에 대한 예외 처리 했기에 접속 가능하다.

**애플리케이션 가동 로그**

애플리케이션이 가동되면 스프링 시큐리티와 관련된 빈도 초기화되어 등록되면서 몇 가지 로그를 확인할 수 있다.

**JwtTokenProvider**

```
[2022-11-09 15:11:42.313] [INFO ][main] com.springboot.security.config.security.JwtTokenProvider [init] JwtTokenProvider 내 secretKey 초기화 시작
[2022-11-09 15:11:42.313] [INFO ][main] com.springboot.security.config.security.JwtTokenProvider [init] JwtTokenProvider 내 SecretKey 초기화 완료
```

`JwtTokenProvider` 클래스는 `@Component`로 등록돼 있고 `@PostConstruct`로 init() 메서드가 정의돼 있다. `init()` 메서드에서 properties에 정의돼 있는 secretkey의 값을 가져와 인코딩 하는 작업을 수행한다.

**DefaultSecurityFilterChain**

```

[2022-35-09 15:35:08.923] [WARN ][main] org.springframework.security.config.annotation.web.builders.WebSecurity You are asking Spring Security to ignore Ant [pattern='/v2/api-docs']. This is not recommended -- please use permitAll via HttpSecurity#authorizeHttpRequests instead.
[2022-35-09 15:35:08.923] [INFO ][main] org.springframework.security.web.DefaultSecurityFilterChain Will not secure Ant [pattern='/v2/api-docs']
[2022-35-09 15:35:08.923] [WARN ][main] org.springframework.security.config.annotation.web.builders.WebSecurity You are asking Spring Security to ignore Ant [pattern='/swagger-resources/**']. This is not recommended -- please use permitAll via HttpSecurity#authorizeHttpRequests instead.
[2022-35-09 15:35:08.923] [INFO ][main] org.springframework.security.web.DefaultSecurityFilterChain Will not secure Ant [pattern='/swagger-resources/**']
[2022-35-09 15:35:08.923] [WARN ][main] org.springframework.security.config.annotation.web.builders.WebSecurity You are asking Spring Security to ignore Ant [pattern='/swagger-ui.html']. This is not recommended -- please use permitAll via HttpSecurity#authorizeHttpRequests instead.
[2022-35-09 15:35:08.923] [INFO ][main] org.springframework.security.web.DefaultSecurityFilterChain Will not secure Ant [pattern='/swagger-ui.html']
[2022-35-09 15:35:08.923] [WARN ][main] org.springframework.security.config.annotation.web.builders.WebSecurity You are asking Spring Security to ignore Ant [pattern='/webjars/**']. This is not recommended -- please use permitAll via HttpSecurity#authorizeHttpRequests instead.
[2022-35-09 15:35:08.923] [INFO ][main] org.springframework.security.web.DefaultSecurityFilterChain Will not secure Ant [pattern='/webjars/**']
[2022-35-09 15:35:08.923] [WARN ][main] org.springframework.security.config.annotation.web.builders.WebSecurity You are asking Spring Security to ignore Ant [pattern='/swagger/**']. This is not recommended -- please use permitAll via HttpSecurity#authorizeHttpRequests instead.
[2022-35-09 15:35:08.923] [INFO ][main] org.springframework.security.web.DefaultSecurityFilterChain Will not secure Ant [pattern='/swagger/**']
[2022-35-09 15:35:08.923] [WARN ][main] org.springframework.security.config.annotation.web.builders.WebSecurity You are asking Spring Security to ignore Ant [pattern='/sign-api/exception']. This is not recommended -- please use permitAll via HttpSecurity#authorizeHttpRequests instead.
[2022-35-09 15:35:08.923] [INFO ][main] org.springframework.security.web.DefaultSecurityFilterChain Will not secure Ant [pattern='/sign-api/exception']
[2022-11-09 15:11:42.600]
[INFO ][main] org.springframework.security.web.DefaultSecurityFilterChain Will secure any request with
[
org.springframework.security.web.session.DisableEncodeUrlFilter@28b47211,
org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@4abb4041,
org.springframework.security.web.context.SecurityContextPersistenceFilter@6b3da23f,
org.springframework.security.web.header.HeaderWriterFilter@df34b01,
org.springframework.security.web.csrf.CsrfFilter@77185a2,
org.springframework.security.web.authentication.logout.LogoutFilter@43c64d6f,
org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter@17f7a1af,
org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter@742aa00a,
org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter@247415be,
org.springframework.security.web.authentication.www.BasicAuthenticationFilter@377cc0f8,
org.springframework.security.web.savedrequest.RequestCacheAwareFilter@5058fefb,
org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@198a0416,
org.springframework.security.web.authentication.AnonymousAuthenticationFilter@48dc9950,
org.springframework.security.web.session.SessionManagementFilter@f31b991,
org.springframework.security.web.access.ExceptionTranslationFilter@cce672c,
org.springframework.security.web.access.intercept.FilterSecurityInterceptor@e280006
]
```

`DefaultSecurityFilterChain`은 `SercurityFilterChain` 인터페이스의 구현체 클래스이다.

**DefaultSecurityFilterChain의 일부 코드**

```java
public final class DefaultSecurityFilterChain implements SecurityFilterChain {
    private static final Log logger = LogFactory.getLog(DefaultSecurityFilterChain.class);
    private final RequestMatcher requestMatcher;
    private final List<Filter> filters;

    public DefaultSecurityFilterChain(RequestMatcher requestMatcher, Filter... filters) {
        this(requestMatcher, Arrays.asList(filters));
    }

    public DefaultSecurityFilterChain(RequestMatcher requestMatcher, List<Filter> filters) {
        if (filters.isEmpty()) {
            logger.info(LogMessage.format("Will not secure %s", requestMatcher));
        } else {
            logger.info(LogMessage.format("Will secure %s with %s", requestMatcher, filters));
        }

        this.requestMatcher = requestMatcher;
        this.filters = new ArrayList(filters);

   // 생략....
    }
}
```

`DefaultSecurityFilterChain`은 `HttpSecurity`에 의해 호출되며, 생성자를 통해 사용될 Filter를 전달받는다.

```java
	@Override
    public void configure(WebSecurity webSecurity){
        webSecurity.ignoring().antMatchers("/v2/api-docs", "/swagger-resources/**",
                "/swagger-ui.html", "/webjars/**", "/swagger/**", "/sign-api/exception");
    }
```

앞서 정의한 `SecurityConfiguration` 클래스에서 설정한 `WebSecurity`를 활용하는 `configure()` 메서드에서 제외한 경로들을 표현하고 있으며, 여기에 나열된 필터를 보면 13.3절에서 소개한 필터 목록의 필터들이 순서대로 나열된 것을 볼 수 있다. 그중 13번 줄에서는 앞에서 생성해서 필터에 추가했던 `JwtAuthenticationFilter`를 볼 수 있다.

### **정상적인 동작 시나리오**

1. 회원가입 성공
2. 회원가입에 성공한 게정 정보를 기반으로 로그인을 성공
    1. 로그인에 성공하면서 토큰을 발급 받음
3. 상품 컨트롤러의 상품 등록 API를 호출
    1. API 호출 시 로그인 과정에서 받은 토큰을 헤더에 추가해서 전달
4. 정상적으로 상품 등록을 마침

![](https://velog.velcdn.com/images/dnrwhddk1/post/e87935f1-dd00-4cd9-9bf1-8bc7f7444b32/image.png)

![](https://velog.velcdn.com/images/dnrwhddk1/post/fd69b03c-fb33-4c4b-afdc-f50f4b5c94e3/image.png)

정상적으로 회원가입 화면 출력 후 로그인을 수행한다.

![](https://velog.velcdn.com/images/dnrwhddk1/post/7121c7a0-446c-49f0-a5a9-a984301638fa/image.png)

![](https://velog.velcdn.com/images/dnrwhddk1/post/e317ebf5-0a6d-4cb4-905b-c23fcf3132a1/image.png)

로그인이 정상적으로 수행되었고 응답으로 온 토큰 값 또한 볼 수 있다. 앞으로 인증이 필요한 리소스에 접근할 때는 이 토큰값을 헤더에 추가해서 전달해야 한다.

상품 등록 API를 통해 상품을 등록해본다.

![](https://velog.velcdn.com/images/dnrwhddk1/post/57090885-5c8d-4314-bfbf-7f3f66d646eb/image.png)

입력값은 다음과 같다.

**헤더**

- X-AUTH-TOKEN : eyH… (로그인 성공 후 발급받은 토큰)

**Body**

- name : 공책
- price : 2000
- stock : 3500

이 과정에서 헤더 값을 입력할 수 있는 폼이 나오지 않는다면 다음과 같이 ProductController 클래스의 `createProduct()` 메서드에 `Swagger의 어노테이션`을 지정한다.

```java
@ApiImplicitParams({
            @ApiImplicitParam(name = "X-AUTH-TOKEN", value = "로그인 성공 후 발급 받은 access_token",
            required = true, dataType = "String", paramType = "header")
    })
    @PostMapping()
    public ResponseEntity<ProductResponseDto> createProduct(@RequestBody ProductDto productDto){
        ProductResponseDto productResponseDto = productService.saveProduct(productDto);

        return ResponseEntity.status(HttpStatus.OK).body(productResponseDto);
    }
```

상품이 정상적으로 등록됐는지 확인하려면 상품 조회 API를 이용해 확인할 수 있다. 조회 기능은 별도의 토큰을 전달하지 않아도 사용수 있게 보안 설정을 했기 때문에 토큰 없이 사용할 수 있다.

---

### **비정상적인 동작 시나리오 - 인증 예외 발생**

비정상적인 동작 크게 두 가지로 구분할 수 있다.

- 인증 실패, 인가 실패

**인증과정 에서 예외 발생 경우**

1. 회원가입에 성공한다
2. 회원가입에 성공한 계정 정보를 기반으로 로그인에 성공한다
3. 상품 컨트롤러의 상품 등록 API를 호출한다
    1. 호출 시 토큰을 변조해서 헤더에 추가
4. 인증 예외 메세지

![](https://velog.velcdn.com/images/dnrwhddk1/post/e0ca14c3-64a1-4488-9796-7c7635009e68/image.png)

![](https://velog.velcdn.com/images/dnrwhddk1/post/4a52831c-d0e3-4a7a-b113-123b1e88687d/image.png)

인증이 실패하여 `CustomAuthenticationEntryPoint`에 구현한 예외 상항에 대한 메세지가 담긴 응답이 애플리케이션에서 생성되고 클라이언트에게 전달된다.

**CustomAuthenticationEntryPoint 클래스**

```java
@Component
public class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint {

    private final Logger LOGGER = LoggerFactory.getLogger(CustomAuthenticationEntryPoint.class);

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
        ObjectMapper objectMapper = new ObjectMapper();
        LOGGER.info("[commence] 인증 실패로 response.sendError 발생");

        EntryPointErrorResponse entryPointErrorResponse = new EntryPointErrorResponse();
        entryPointErrorResponse.setMsg("인증이 실패하였습니다");

        response.setStatus(401);
        response.setContentType("application/json");
        response.setCharacterEncoding("utf-8");
        response.getWriter().write(objectMapper.writeValueAsString(entryPointErrorResponse));
    }
}
```

**인가 예외 상황인 경우**

1. 회원가입에 성공한다
2. 회원가입에 성공한 계정 정보를 기반으로 로그인에 성공한다
3. 상품 컨트롤러의 상품 등록 API를 호출한다
    1. API 호출 시 로그인 과정에서 받은 토큰을 헤더에 추가한 후 전달
4. 인가 예외 발생으로 `/exception`으로 리다이렉트 후 예외 메시지가 응답으로 돌아온다

현재 권한은 ADMIN에게만 부여돼 있고 USER에게는 부여되지 않은 상황이기 때문에, 새로운 회원가입 단계에서 USER 권한을 받으면 이 시나리오를 진행할 수 있다.

![](https://velog.velcdn.com/images/dnrwhddk1/post/a0135f83-f0c8-4026-87b7-c6d62d4d4b98/image.png)

![](https://velog.velcdn.com/images/dnrwhddk1/post/92b7aa84-1006-4241-ba03-6b4a53b138c1/image.png)

상품 등록 API를 호출했을 때 권한이 없기 때문에 인가 예외가 발생한다.

![](https://velog.velcdn.com/images/dnrwhddk1/post/bf4d82ea-1ac8-46fe-8308-7f8e6f337022/image.png)

```
[2022-49-09 16:49:12.990] [INFO ][http-nio-8080-exec-8] com.springboot.security.config.security.JwtAuthenticationFilter [doFilterInternal] token 값 추출 완료. token : eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJmZHNhMTIzNCIsInJvbGVzIjpbIlJPTEVfVVNFUiJdLCJpYXQiOjE2Njc5ODAwODgsImV4cCI6MTY2Nzk4MzY4OH0.OsCBVrNSIX1MuOtpZwCpqA7RUrin80x2_VRHKg8Ik0c
[2022-49-09 16:49:12.990] [INFO ][http-nio-8080-exec-8] com.springboot.security.config.security.JwtAuthenticationFilter [doFilterInternal] token 값 유효성 체크 시작
[2022-49-09 16:49:12.990] [INFO ][http-nio-8080-exec-8] com.springboot.security.config.security.JwtTokenProvider [validateToken] 토큰 유효 체크 시작
[2022-49-09 16:49:12.993] [INFO ][http-nio-8080-exec-8] com.springboot.security.config.security.JwtTokenProvider [validateToken] 토큰 유효 체크 완료
[2022-49-09 16:49:12.993] [INFO ][http-nio-8080-exec-8] com.springboot.security.config.security.JwtTokenProvider [getAuthentication] 토큰 인증 정보 조회 시작
[2022-49-09 16:49:12.993] [INFO ][http-nio-8080-exec-8] com.springboot.security.config.security.JwtTokenProvider [getUsername] 토큰 기반 회원 구별 정보 추출
[2022-49-09 16:49:12.994] [INFO ][http-nio-8080-exec-8] com.springboot.security.config.security.JwtTokenProvider [getUsername] 토큰 기반 회원 구별 정보 추출 완료, info : fdsa1234
[2022-49-09 16:49:12.994] [INFO ][http-nio-8080-exec-8] com.springboot.security.service.impl.UserDetailsServiceImpl [loadUserByUsername] loadUserByUsername 수행. username : fdsa1234

[2022-49-09 16:49:13.002] [INFO ][http-nio-8080-exec-8] com.springboot.security.config.security.JwtTokenProvider [getAuthentication] 토큰 인증 정보 조회 완료, UserDetails UserName : fdsa1234
[2022-49-09 16:49:13.003] [INFO ][http-nio-8080-exec-8] com.springboot.security.config.security.JwtAuthenticationFilter [doFilterInternal] token 값 유효성 체크 완료
[2022-49-09 16:49:13.005] [INFO ][http-nio-8080-exec-8] com.springboot.security.config.security.CustomAccessDeniedHandler [handle] 접근이 막혔을 경우 경로 리다이렉트
[2022-49-09 16:49:13.009] [ERROR][http-nio-8080-exec-9] com.springboot.security.controller.SignController ExceptionHandler 호출, null, 접근이 금지되었습니다.
```

인증은 정상적으로 수행되었지만 인가가 실패해서 접근이 막힌다.

- 인가 예외에 대한 처리는 `CustomAccessDeniedHandler`에서 수행됨

---

스프링 시큐리티는 매우 다양한 방법으로 구현할 수 있게 설계돼 있다. 로그인 폼을 사용해 로그인과 회원가입 기능을 개발할 수도 있으며, OAuth나 소셜 로그인을 연동해서도 구현할 수 있다.

어떤 애플리케이션을 개발하느냐에 따라 서비스의 특성에 맞게 스프링 시큐리티를 적용해야 한다. 가령 외부에 노출되지 않는 일부 서비스는 성능 상의 이점을 살리기 위해 스프링 시큐리티를 적용하지 않을 수도 있다.